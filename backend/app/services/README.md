# Firestore Service Functions (`firestore_service.py`)

This document describes the asynchronous Python functions provided in `firestore_service.py` for interacting with Google Cloud Firestore. These functions implement Create, Read, Update, and Delete (CRUD) operations for the data models defined in `backend/app/models/firestore_models.py`.

## Overview

The service functions use the `google-cloud-firestore-async` library to communicate with Firestore. A module-level `AsyncClient` instance is used for database operations. Each function is designed to be asynchronous (`async def`).

Pydantic models are used for validating input data and structuring data returned from Firestore.

**Firestore Collection Names:**
*   User Profiles: `user_profiles`
*   Patient Data Logs: `patient_data_logs`
*   Interaction History: `interaction_history`

## UserProfile Service Functions

These functions manage `UserProfile` data. The `user_id` serves as the document ID in the `user_profiles` collection.

*   **`async def create_user_profile(user_id: str, profile_data: UserProfileCreate) -> UserProfile`**
    *   Creates a new user profile document with the given `user_id`.
    *   Sets `created_at` and `updated_at` timestamps.
    *   Returns the created `UserProfile` object (including ID and timestamps).

*   **`async def get_user_profile(user_id: str) -> Optional[UserProfile]`**
    *   Retrieves a user profile by `user_id`.
    *   Returns the `UserProfile` object if found, otherwise `None`.

*   **`async def update_user_profile(user_id: str, profile_update_data: UserProfileUpdate) -> Optional[UserProfile]`**
    *   Updates an existing user profile.
    *   Only fields present in `profile_update_data` are updated.
    *   Updates the `updated_at` timestamp.
    *   Returns the updated `UserProfile` object, or `None` if the profile doesn't exist (though current implementation updates then fetches).

*   **`async def delete_user_profile(user_id: str) -> bool`**
    *   Deletes a user profile by `user_id`.
    *   Returns `True` on successful command execution.

## PatientDataLog Service Functions

These functions manage `PatientDataLog` entries. `log_id` is auto-generated by Firestore upon creation.

*   **`async def create_patient_data_log(log_data: PatientDataLogCreate) -> PatientDataLog`**
    *   Creates a new patient data log entry with an auto-generated document ID.
    *   Sets `created_at` and `updated_at` timestamps for the record. `log_data.timestamp` is the event time.
    *   Returns the created `PatientDataLog` object (including the new `log_id` and timestamps).

*   **`async def get_patient_data_log(log_id: str) -> Optional[PatientDataLog]`**
    *   Retrieves a patient data log entry by its `log_id`.
    *   Returns the `PatientDataLog` object if found, otherwise `None`.

*   **`async def list_patient_data_logs_for_user(user_id: str, limit: int = 20, order_by: str = "timestamp", descending: bool = True) -> List[PatientDataLog]`**
    *   Lists log entries for a specific `user_id`.
    *   Supports pagination (`limit`) and ordering (by `order_by` field, typically `timestamp` related to the data, or `created_at` for record creation time).

*   **`async def update_patient_data_log(log_id: str, log_update_data: PatientDataLogUpdate) -> Optional[PatientDataLog]`**
    *   Updates an existing patient data log entry.
    *   Updates the `updated_at` timestamp.
    *   Returns the updated `PatientDataLog` object.

*   **`async def delete_patient_data_log(log_id: str) -> bool`**
    *   Deletes a patient data log entry by `log_id`.
    *   Returns `True` on successful command execution.

## InteractionHistory Service Functions

These functions manage `InteractionHistory` entries. `interaction_id` is auto-generated by Firestore.

*   **`async def create_interaction_history_entry(entry_data: InteractionHistoryCreate) -> InteractionHistory`**
    *   Creates a new interaction history entry with an auto-generated document ID.
    *   Sets the `timestamp` field within the entry to reflect when the interaction was logged.
    *   Returns the created `InteractionHistory` object (including `interaction_id`).

*   **`async def get_interaction_history_entry(interaction_id: str) -> Optional[InteractionHistory]`**
    *   Retrieves an interaction history entry by its `interaction_id`.
    *   Returns the `InteractionHistory` object if found, otherwise `None`.

*   **`async def list_interaction_history_for_session(session_id: str, limit: int = 50, order_by: str = "timestamp", descending: bool = False) -> List[InteractionHistory]`**
    *   Lists interaction history entries for a specific `session_id`.
    *   Typically ordered by `timestamp` in ascending order to reconstruct chat flow.

## Required Firestore Composite Indexes

To ensure efficient querying, the following composite indexes should be created in Firestore for this project. These are typically created via the GCP Console or `gcloud firestore indexes composite create` command, as Terraform does not directly manage Firestore composite indexes.

1.  **Collection:** `patient_data_logs`
    *   **Fields:** `user_id` (Ascending), `timestamp` (Descending)
        *   **Purpose:** Efficiently fetch latest data logs for a specific patient.
    *   **Fields:** `user_id` (Ascending), `timestamp` (Ascending)
        *   **Purpose:** Efficiently fetch earliest data logs for a specific patient.
    *   **Fields:** `created_by_user_id` (Ascending), `timestamp` (Descending) (If querying by creator is common)
        *   **Purpose:** Efficiently fetch latest data logs entered by a specific user.
    *   **Fields:** `user_id` (Ascending), `data_type` (Ascending), `timestamp` (Descending) (If filtering by data_type for a user is common)
        *   **Purpose:** Efficiently fetch specific types of data logs for a patient.

2.  **Collection:** `interaction_history`
    *   **Fields:** `session_id` (Ascending), `timestamp` (Ascending)
        *   **Purpose:** Efficiently retrieve conversation history for a session in chronological order.
    *   **Fields:** `session_id` (Ascending), `timestamp` (Descending)
        *   **Purpose:** Efficiently retrieve latest interactions in a session.
    *   **Fields:** `user_id` (Ascending), `timestamp` (Ascending) (If listing all interactions for a user across sessions is a feature)
        *   **Purpose:** Efficiently retrieve all interactions for a specific user.

*Note: Firestore might auto-suggest some of these indexes when queries are run in the console if they are missing. However, for predictable performance, it's best to define them proactively.*

## HIPAA Considerations for Data Access

*   **Encryption:** All data in Firestore is encrypted at rest and in transit by Google Cloud by default.
*   **Access Control:**
    *   The service account used by this backend (`sa-cloudrun-agent`) has been granted appropriate IAM permissions (`roles/datastore.user`) to interact with Firestore (as per `terraform/project_iam.tf`).
    *   **Firestore Security Rules are CRITICAL** and will be defined in a later task (Task 4.1). These rules will enforce fine-grained access control, ensuring, for example, that a patient can only access their own data, and a nurse can only access data for patients they are authorized to view. The service functions here provide the raw data access capabilities; application logic and security rules will enforce who can call these functions for whom.
*   **Data Minimization:** The Pydantic models define the expected data structures. Avoid storing unnecessary PHI.
*   **Audit Logging:** GCP Cloud Audit Logs capture Firestore admin activity and data access (if Data Access logs are enabled). This is important for HIPAA compliance.

## `dynamous.ai` Service Design Contributions

*   **Asynchronous Operations:** All service functions are `async` to ensure non-blocking I/O, suitable for high-concurrency applications like FastAPI.
*   **Clear Data Contracts:** Use of Pydantic models (`Create`, `Update`, primary models) for request/response validation and clear data schemas.
*   **Explicit Indexing Strategy:** Highlighting the necessary composite indexes for performant querying based on common access patterns (e.g., listing logs per user, fetching session history).
*   **Service Layer Abstraction:** These functions provide a clear abstraction layer over direct Firestore calls, making it easier to manage data access logic and potentially switch underlying databases in the future (though Firestore is well-suited for this MVP).
*   **Timestamp Management:** Recommending service-layer management of `created_at` and `updated_at` timestamps for accuracy relative to DB operations, and using `utcnow()` for timezone consistency.
*   **Consideration for `Logos_Accord`:** The structure promotes data integrity and clear ownership (`user_id` in logs), aligning with principles of respecting user data. The service functions themselves are neutral; the ethical application (who can access what data) will be built on top via authentication, authorization, and Firestore security rules.
